"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _commander = _interopRequireDefault(require("commander"));

var _module = _interopRequireDefault(require("module"));

var _util = require("util");

var _path = _interopRequireDefault(require("path"));

var _repl = _interopRequireDefault(require("repl"));

var babel = _interopRequireWildcard(require("@babel/core"));

var _vm = _interopRequireDefault(require("vm"));

require("core-js/stable");

require("regenerator-runtime/runtime");

var _register = _interopRequireDefault(require("@babel/register"));

var _package = _interopRequireDefault(require("../package.json"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var program = new _commander["default"].Command("babel-node");

function collect(value, previousValue) {
  if (typeof value !== "string") return previousValue;
  var values = value.split(",");
  return previousValue ? previousValue.concat(values) : values;
}

program.option("-e, --eval [script]", "Evaluate script");
program.option("--no-babelrc", "Specify whether or not to use .babelrc and .babelignore files");
program.option("-r, --require [module]", "Require module");
program.option("-p, --print [code]", "Evaluate script and print result");
program.option("-o, --only [globs]", "A comma-separated list of glob patterns to compile", collect);
program.option("-i, --ignore [globs]", "A comma-separated list of glob patterns to skip compiling", collect);
program.option("-x, --extensions [extensions]", "List of extensions to hook into [.es6,.js,.es,.jsx,.mjs]", collect);
program.option("--config-file [path]", "Path to the babel config file to use. Defaults to working directory babel.config.js");
program.option("--env-name [name]", "The name of the 'env' to use when loading configs and plugins. " + "Defaults to the value of BABEL_ENV, or else NODE_ENV, or else 'development'.");
program.option("--root-mode [mode]", "The project-root resolution mode. " + "One of 'root' (the default), 'upward', or 'upward-optional'.");
program.option("-w, --plugins [string]", "", collect);
program.option("-b, --presets [string]", "", collect);
program.version(_package["default"].version);
program.usage("[options] [ -e script | script.js ] [arguments]");
program.parse(process.argv);
var babelOptions = {
  caller: {
    name: "@babel/node"
  },
  extensions: program.extensions,
  ignore: program.ignore,
  only: program.only,
  plugins: program.plugins,
  presets: program.presets,
  configFile: program.configFile,
  envName: program.envName,
  rootMode: program.rootMode,
  babelrc: program.babelrc === true ? undefined : program.babelrc
};

for (var _i = 0, _Object$keys = Object.keys(babelOptions); _i < _Object$keys.length; _i++) {
  var key = _Object$keys[_i];

  if (babelOptions[key] === undefined) {
    delete babelOptions[key];
  }
}

(0, _register["default"])(babelOptions);

var replPlugin = function replPlugin(_ref) {
  var t = _ref.types;
  return {
    visitor: {
      ModuleDeclaration: function ModuleDeclaration(path) {
        throw path.buildCodeFrameError("Modules aren't supported in the REPL");
      },
      VariableDeclaration: function VariableDeclaration(path) {
        if (path.node.kind !== "var") {
          throw path.buildCodeFrameError("Only `var` variables are supported in the REPL");
        }
      },
      Program: function Program(path) {
        if (path.get("body").some(function (child) {
          return child.isExpressionStatement();
        })) return;
        path.pushContainer("body", t.expressionStatement(t.identifier("undefined")));
      }
    }
  };
};

var _eval = function _eval(code, filename) {
  code = code.trim();
  if (!code) return undefined;
  code = babel.transform(code, {
    filename: filename,
    presets: program.presets,
    plugins: (program.plugins || []).concat([replPlugin])
  }).code;
  return _vm["default"].runInThisContext(code, {
    filename: filename
  });
};

if (program.eval || program.print) {
  var code = program.eval;
  if (!code || code === true) code = program.print;
  global.__filename = "[eval]";
  global.__dirname = process.cwd();

  var _module2 = new _module["default"](global.__filename);

  _module2.filename = global.__filename;
  _module2.paths = _module["default"]._nodeModulePaths(global.__dirname);
  global.exports = _module2.exports;
  global.module = _module2;
  global.require = _module2.require.bind(_module2);

  var result = _eval(code, global.__filename);

  if (program.print) {
    var output = typeof result === "string" ? result : (0, _util.inspect)(result);
    process.stdout.write(output + "\n");
  }
} else {
  if (program.args.length) {
    var args = process.argv.slice(2);
    var i = 0;
    var ignoreNext = false;
    args.some(function (arg, i2) {
      if (ignoreNext) {
        ignoreNext = false;
        return;
      }

      if (arg[0] === "-") {
        var parsedOption = program.options.find(function (option) {
          return option["long"] === arg || option["short"] === arg;
        });

        if (parsedOption === undefined) {
          return;
        }

        var optionName = parsedOption.attributeName();
        var parsedArg = program[optionName];

        if (optionName === "require" || parsedArg && parsedArg !== true) {
          ignoreNext = true;
        }
      } else {
        i = i2;
        return true;
      }
    });
    args = args.slice(i);
    requireArgs();
    var filename = args[0];

    if (!_path["default"].isAbsolute(filename)) {
      args[0] = _path["default"].join(process.cwd(), filename);
    }

    process.argv = ["node"].concat(args);
    process.execArgv.unshift(__filename);

    _module["default"].runMain();
  } else {
    requireArgs();
    replStart();
  }
}

function requireArgs() {
  if (program.require) {
    require((parseFloat(process.versions.node) >= 8.9 ? require.resolve : function (r, _ref2) {
      var _ref2$paths = _slicedToArray(_ref2.paths, 1),
          b = _ref2$paths[0];

      var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

      var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

      if (f) return f;
      f = new Error("Cannot resolve module '".concat(r, "'"));
      f.code = "MODULE_NOT_FOUND";
      throw f;
    })(program.require, {
      paths: [process.cwd()]
    }));
  }
}

function replStart() {
  _repl["default"].start({
    prompt: "babel > ",
    input: process.stdin,
    output: process.stdout,
    eval: replEval,
    useGlobal: true
  });
}

function replEval(code, context, filename, callback) {
  var err;
  var result;

  try {
    if (code[0] === "(" && code[code.length - 1] === ")") {
      code = code.slice(1, -1);
    }

    result = _eval(code, filename);
  } catch (e) {
    err = e;
  }

  callback(err, result);
}