"use strict";

var definitions = require("../../lib/definitions");

var formatBuilderName = require("../utils/formatBuilderName");

var lowerFirst = require("../utils/lowerFirst");

var t = require("../../");

var stringifyValidator = require("../utils/stringifyValidator");

function areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {
  var index = fieldNames.indexOf(fieldName);
  return fieldNames.slice(index).every(function (_) {
    return isNullable(fields[_]);
  });
}

function hasDefault(field) {
  return field["default"] != null;
}

function isNullable(field) {
  return field.optional || hasDefault(field);
}

function sortFieldNames(fields, type) {
  return fields.sort(function (fieldA, fieldB) {
    var indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    var indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}

function generateBuilderArgs(type) {
  var fields = t.NODE_FIELDS[type];
  var fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);
  var builderNames = t.BUILDER_KEYS[type];
  var args = [];
  fieldNames.forEach(function (fieldName) {
    var field = fields[fieldName]; // Future / annoying TODO:
    // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:
    // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,
    // - declare an alias type for valid keys, detect the case and reuse it here,
    // - declare a disjoint union with, for example, ObjectPropertyBase,
    //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty
    //   as "ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)"

    var typeAnnotation = stringifyValidator(field.validate, "t.");

    if (isNullable(field) && !hasDefault(field)) {
      typeAnnotation += " | null";
    }

    if (builderNames.includes(fieldName)) {
      var bindingIdentifierName = t.toBindingIdentifierName(fieldName);

      if (areAllRemainingFieldsNullable(fieldName, builderNames, fields)) {
        args.push("".concat(bindingIdentifierName).concat(isNullable(field) ? "?:" : ":", " ").concat(typeAnnotation));
      } else {
        args.push("".concat(bindingIdentifierName, ": ").concat(typeAnnotation).concat(isNullable(field) ? " | undefined" : ""));
      }
    }
  });
  return args;
}

module.exports = function generateBuilders(kind) {
  return kind === "uppercase.js" ? generateUppercaseBuilders() : generateLowercaseBuilders();
};

function generateLowercaseBuilders() {
  var output = "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport builder from \"../builder\";\nimport type * as t from \"../..\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n";
  var reservedNames = new Set(["super", "import"]);
  Object.keys(definitions.BUILDER_KEYS).forEach(function (type) {
    var defArgs = generateBuilderArgs(type);
    var formatedBuilderName = formatBuilderName(type);
    var formatedBuilderNameLocal = reservedNames.has(formatedBuilderName) ? "_".concat(formatedBuilderName) : formatedBuilderName;
    output += "".concat(formatedBuilderNameLocal === formatedBuilderName ? "export " : "", "function ").concat(formatedBuilderNameLocal, "(").concat(defArgs.join(", "), "): t.").concat(type, " { return builder(\"").concat(type, "\", ...arguments); }\n");

    if (formatedBuilderNameLocal !== formatedBuilderName) {
      output += "export { ".concat(formatedBuilderNameLocal, " as ").concat(formatedBuilderName, " };\n");
    } // This is needed for backwards compatibility.
    // It should be removed in the next major version.
    // JSXIdentifier -> jSXIdentifier


    if (/^[A-Z]{2}/.test(type)) {
      output += "export { ".concat(formatedBuilderNameLocal, " as ").concat(lowerFirst(type), " }\n");
    }
  });
  Object.keys(definitions.DEPRECATED_KEYS).forEach(function (type) {
    var newType = definitions.DEPRECATED_KEYS[type];
    var formatedBuilderName = formatBuilderName(type);
    output += "/** @deprecated */\nfunction ".concat(type, "(...args: Array<any>): any {\n  console.trace(\"The node type ").concat(type, " has been renamed to ").concat(newType, "\");\n  return builder(\"").concat(type, "\", ...args);\n}\nexport { ").concat(type, " as ").concat(formatedBuilderName, " };\n"); // This is needed for backwards compatibility.
    // It should be removed in the next major version.
    // JSXIdentifier -> jSXIdentifier

    if (/^[A-Z]{2}/.test(type)) {
      output += "export { ".concat(type, " as ").concat(lowerFirst(type), " }\n");
    }
  });
  return output;
}

function generateUppercaseBuilders() {
  var output = "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/**\n * This file is written in JavaScript and not TypeScript because uppercase builders\n * conflict with AST types. TypeScript reads the uppercase.d.ts file instead.\n */\n\n export {\n";
  Object.keys(definitions.BUILDER_KEYS).forEach(function (type) {
    var formatedBuilderName = formatBuilderName(type);
    output += "  ".concat(formatedBuilderName, " as ").concat(type, ",\n");
  });
  Object.keys(definitions.DEPRECATED_KEYS).forEach(function (type) {
    var formatedBuilderName = formatBuilderName(type);
    output += "  ".concat(formatedBuilderName, " as ").concat(type, ",\n");
  });
  output += " } from './index';\n";
  return output;
}